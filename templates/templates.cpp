#include <iostream>
#include <cstring>

using namespace std;

// A function template is a blueprint for creating functions
// that work with any data type.
// Instead of writing separate functions for each type, you define a single template,
// and the compiler generates the appropriate version of the function at compile time.

// Function templates are just blueprints. They're not real C++ code consumed by the compiler.
// The compiler generates real C++ code by looking at the arguments you call your func template with.

// The real C++ func generated by the compiler is called a template instance.

// A template instance will be reused when a similar function call (arg type) is issued.
// No duplicates are generated by the compiler.

template <typename T>
T maximum(T a, T b);

// Template specialization: a specific implementation of a template for a particular type
template <>
const char *maximum<const char *>(const char *a, const char *b);

template <typename T>
const T &maximum1(const T &a, const T &b);

int main(int argc, char **argv)
{
    int a = 10;
    int b = 23;

    double c = 34.7;
    double d = 23.4;

    string e = "hello";
    string f = "world";

    maximum(a, b); // int type deduced
    maximum(c, d); // double type deduced
    maximum(e, f); // string type deduced

    // Explicit template arguments
    maximum<double>(c, d); // explicitly say that we want double
                           // version called, if an instance is not already,
                           // it will be created.
    maximum<double>(a, c); // works, even if parameters are of different types,
                           // there is implicit conversions from int to double
                           // for the first parameter
    // maximum<double>(a, e); // Error: can't convert string to double

    cout << "max(int) : " << maximum(a, b) << endl;    // int version created
    cout << "max(double) : " << maximum(c, d) << endl; // double version created
    cout << "max(string) : " << maximum(e, f) << endl; // string version created

    // Template type parameters by reference
    cout << "Out - &a: " << &a << endl;
    cout << "max1: " << maximum1(a, b) << endl;

    // Using the specialized template func
    const char *g{"wild"};
    const char *h{"animal"};

    cout << "max(const char*) : " << maximum(g, h) << endl;
}

// Template type parameters by value
template <typename T>
T maximum(T a, T b)
{
    return (a > b) ? a : b; // a and b must support the > operator. otherwise, error.
}

// Specializing maximum for const char*
template <>
const char *maximum<const char *>(const char *a, const char *b)
{
    return (strcmp(a, b) > 0) ? a : b;
}

// Template type parameters by reference
template <typename T>
const T &maximum1(const T &a, const T &b)
{
    cout << "In - &a: " << &a << endl;
    return (a > b) ? a : b;
}
